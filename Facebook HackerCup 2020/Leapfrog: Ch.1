// Question -->>
//Let b be the number of Beta Frogs. We’ll begin by optimally arranging these b Beta Frogs across lilypads 2..N, noting that any such arrangement is possible to achieve regardless of their particular initial positions. Once we settle on an arrangement, we’ll proceed to hopefully have the Alpha Frog make one or more leaps starting from lilypad 1 and ending at lilypad N.
//Any arrangement of Beta Frogs consists of zero or more contiguous sequences of frogs, separated by unoccupied lilypads. Each contiguous sequence of x Beta Frogs allows the Alpha Frog to advance by x + 1 lilypads. Another way of thinking about that is that each individual Beta Frog allows the Alpha Frog to advance by either 2 lilypads (if it’s the final Beta Frog in a sequence), or 1 lilypad otherwise. This suggests that the minimum total number of lilypads by which the Alpha Frog can advance is b + 1, while the maximum number is 2 * b. We can then claim that the Alpha Frog can advance by the required total of exactly N - 1 lilypads if and only if b + 1 ≤ N - 1 and N - 1 ≤ 2 * b — in other words, if and only if ⌊N / 2⌋ ≤ b ≤ N - 2. Intuitively, this lower bound corresponds to spacing out Beta Frogs in as many single-frog sequences as possible (e.g. AB.B.B.B. or AB.B.B.BB.), while the upper bound corresponds to filling all but the first and last lilypads with Beta Frogs (e.g. ABBBBB.).

// Solution -->

#define DEBUG 0

#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <complex>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <sstream>
using namespace std;

#define LL long long
#define LD long double
#define PR pair<int,int>

#define Fox(i,n) for (i=0; i<n; i++)
#define Fox1(i,n) for (i=1; i<=n; i++)
#define FoxI(i,a,b) for (i=a; i<=b; i++)
#define FoxR(i,n) for (i=(n)-1; i>=0; i--)
#define FoxR1(i,n) for (i=n; i>0; i--)
#define FoxRI(i,a,b) for (i=b; i>=a; i--)
#define Foxen(i,s) for (i=s.begin(); i!=s.end(); i++)
#define Min(a,b) a=min(a,b)
#define Max(a,b) a=max(a,b)
#define Sz(s) int((s).size())
#define All(s) (s).begin(),(s).end()
#define Fill(s,v) memset(s,v,sizeof(s))
#define pb push_back
#define mp make_pair
#define x first
#define y second

template<typename T> T Abs(T x) { return(x<0 ? -x : x); }
template<typename T> T Sqr(T x) { return(x*x); }
string plural(string s) { return(Sz(s) && s[Sz(s)-1]=='x' ? s+"en" : s+"s"); }

const int INF = (int)1e9;
const LD EPS = 1e-12;
const LD PI = acos(-1.0);

#if DEBUG
#define GETCHAR getchar
#else
#define GETCHAR getchar_unlocked
#endif

bool Read(int &x)
{
	char c,r=0,n=0;
	x=0;
		for(;;)
		{
			c=GETCHAR();
				if ((c<0) && (!r))
					return(0);
				if ((c=='-') && (!r))
					n=1;
				else
				if ((c>='0') && (c<='9'))
					x=x*10+c-'0',r=1;
				else
				if (r)
					break;
		}
		if (n)
			x=-x;
	return(1);
}

int main()
{
		if (DEBUG)
			freopen("in.txt","r",stdin);
	// vars
	int T,t;
	int N;
	int i,c;
	char S[5005];
	// testcase loop
	Read(T);
		Fox1(t,T)
		{
			// input
			scanf("%s",&S);
			N=strlen(S);
			// count B's
			c=0;
				Fox(i,N)
					c+=S[i]=='B';
			// output
			printf("Case #%d: %c\n",t,(N/2<=c && c<=N-2)?'Y':'N');
		}
	return(0);
}
