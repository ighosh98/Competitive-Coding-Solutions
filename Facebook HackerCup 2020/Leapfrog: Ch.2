// Question -->>
//As in Leapfrog: Ch. 1, if there are b Beta Frogs, the Alpha Frog can still reach lilypad N if ⌊N / 2⌋ ≤ b ≤ N - 2. If b > N - 2, it’s still impossible, as lilypad N must be occupied by a Beta Frog. However, it may now additionally be possible even when b < ⌊N / 2⌋.
//Let’s consider what the Alpha Frog and two Beta Frogs can accomplish when working together. We’ll take an initial state with N = 5 and b = 2, and consider the following sequence of moves:
//AB.B.
//.BAB.
//.B.BA
//..BBA
//.ABB.
//Observe that this sequence has allowed the Alpha Frog to advance by one lilypad, while keeping both Beta Frogs to the right of it! This effectively returns us the initial state, just with N reduced by 1. More lilypads and more Beta Frogs don’t prevent this sequence, suggesting that it may be expanded to allow the Alpha Frog to eventually reach lilypad N whenever N ≥ 5 and b ≥ 2.
//Bringing everything together, we can state that it’s possible if and only if min{ 2, ⌊N / 2⌋ } ≤ b ≤ N - 2.


// Solution -->>

#define DEBUG 0

#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <complex>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <sstream>
using namespace std;

#define LL long long
#define LD long double
#define PR pair<int,int>

#define Fox(i,n) for (i=0; i<n; i++)
#define Fox1(i,n) for (i=1; i<=n; i++)
#define FoxI(i,a,b) for (i=a; i<=b; i++)
#define FoxR(i,n) for (i=(n)-1; i>=0; i--)
#define FoxR1(i,n) for (i=n; i>0; i--)
#define FoxRI(i,a,b) for (i=b; i>=a; i--)
#define Foxen(i,s) for (i=s.begin(); i!=s.end(); i++)
#define Min(a,b) a=min(a,b)
#define Max(a,b) a=max(a,b)
#define Sz(s) int((s).size())
#define All(s) (s).begin(),(s).end()
#define Fill(s,v) memset(s,v,sizeof(s))
#define pb push_back
#define mp make_pair
#define x first
#define y second

template<typename T> T Abs(T x) { return(x<0 ? -x : x); }
template<typename T> T Sqr(T x) { return(x*x); }
string plural(string s) { return(Sz(s) && s[Sz(s)-1]=='x' ? s+"en" : s+"s"); }

const int INF = (int)1e9;
const LD EPS = 1e-12;
const LD PI = acos(-1.0);

#if DEBUG
#define GETCHAR getchar
#else
#define GETCHAR getchar_unlocked
#endif

bool Read(int &x)
{
	char c,r=0,n=0;
	x=0;
		for(;;)
		{
			c=GETCHAR();
				if ((c<0) && (!r))
					return(0);
				if ((c=='-') && (!r))
					n=1;
				else
				if ((c>='0') && (c<='9'))
					x=x*10+c-'0',r=1;
				else
				if (r)
					break;
		}
		if (n)
			x=-x;
	return(1);
}

int main()
{
		if (DEBUG)
			freopen("in.txt","r",stdin);
	// vars
	int T,t;
	int N;
	int i,c;
	char S[5005];
	// testcase loop
	Read(T);
		Fox1(t,T)
		{
			// input
			scanf("%s",&S);
			N=strlen(S);
			// count B's
			c=0;
				Fox(i,N)
					c+=S[i]=='B';
			// output
			printf("Case #%d: %c\n",t,(min(2,N/2)<=c && c<=N-2)?'Y':'N');
		}
	return(0);
}
